<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互動式蟻群演算法教學 (ACO Visualization)</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #4CAF50;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* 左側控制與教學區 */
        #sidebar {
            width: 350px;
            background-color: var(--panel-color);
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 { font-size: 1.5rem; margin-top: 0; color: var(--accent-color); }
        h2 { font-size: 1.1rem; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        p { font-size: 0.9rem; line-height: 1.5; color: #ccc; }

        .control-group {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
        }

        label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            width: 100%;
            transition: background 0.3s;
        }

        button:hover { background-color: #45a049; }

        .stats { font-family: monospace; font-size: 0.85rem; color: #888; }

        /* 右側畫布區 */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #000;
            cursor: crosshair;
        }

        canvas { display: block; }

        .legend {
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
            margin-top: 5px;
        }
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; }
    </style>
</head>
<body>

    <div id="sidebar">
        <div>
            <h1>蟻群演算法教學</h1>
            <p>Ant Colony Optimization (ACO)</p>
        </div>

        <div class="control-group">
            <h2>原理說明</h2>
            <p>1. <strong>探索</strong>：螞蟻隨機探索環境。</p>
            <p>2. <strong>費洛蒙</strong>：
                <br><span style="color:#55abff">● 藍色</span>：螞蟻留下的「家」的氣味。
                <br><span style="color:#ff5555">● 紅色</span>：拿到食物後留下的「食物」氣味。
            </p>
            <p>3. <strong>正回饋</strong>：螞蟻傾向走向費洛蒙濃度高的地方，隨著更多螞蟻走過同一條路，路徑會越來越清晰。</p>
            <p>4. <strong>揮發</strong>：費洛蒙會隨時間消失，防止陷入局部最佳解。</p>
        </div>

        <div class="control-group">
            <h2>參數控制</h2>
            
            <label>螞蟻數量: <span id="antCountVal">200</span></label>
            <input type="range" id="antCount" min="10" max="1000" value="200">

            <label>費洛蒙揮發速度 (快 <-> 慢): <span id="evapVal">0.97</span></label>
            <input type="range" id="evaporation" min="0.80" max="0.99" step="0.01" value="0.97">

            <label>感測距離: <span id="sensorVal">30</span></label>
            <input type="range" id="sensorDist" min="10" max="60" value="30">

            <button id="resetBtn">重置模擬</button>
        </div>

        <div class="stats">
            <p>提示：拖曳綠色圓圈(家)或紅色圓圈(食物)來改變位置。</p>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
    </div>

    <script>
        /**
         * 蟻群算法模擬器核心邏輯
         */
        
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // 優化性能
        const container = document.getElementById('canvas-container');

        // 參數設置
        let config = {
            antCount: 200,
            evaporationRate: 0.97,
            sensorAngle: Math.PI / 4, // 45度
            sensorDist: 30,
            turnSpeed: 0.2,
            moveSpeed: 2,
            gridSize: 4 // 網格大小，越小越精細但越慢
        };

        let width, height;
        let rows, cols;
        
        // 費洛蒙網格 [ToHome, ToFood]
        // grid[y][x][0] = 藍色 (指引回家的路，由出門的螞蟻留下，或由回家的螞蟻追蹤)
        // 修正邏輯：
        // 沒食物的螞蟻 (Seeking Food) -> 留下 Blue (Home Pheromone), 追蹤 Red (Food Pheromone)
        // 有食物的螞蟻 (Carrying Food) -> 留下 Red (Food Pheromone), 追蹤 Blue (Home Pheromone)
        let grid = []; 

        let ants = [];
        let home = { x: 100, y: 100, r: 15, color: '#4CAF50', dragging: false };
        let food = { x: 400, y: 300, r: 15, color: '#F44336', dragging: false };

        // 初始化
        function init() {
            resize();
            resetGrid();
            spawnAnts();
            loop();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            rows = Math.ceil(height / config.gridSize);
            cols = Math.ceil(width / config.gridSize);
            resetGrid(); // 大小改變時重置網格
        }

        function resetGrid() {
            grid = new Float32Array(rows * cols * 2); // 使用一維陣列優化性能: even index=blue, odd index=red
        }

        function spawnAnts() {
            ants = [];
            for (let i = 0; i < config.antCount; i++) {
                ants.push(new Ant());
            }
        }

        // 螞蟻類別
        class Ant {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = home.x;
                this.y = home.y;
                this.angle = Math.random() * Math.PI * 2;
                this.hasFood = false;
            }

            update() {
                // 1. 留下費洛蒙 (在當前位置)
                let gx = Math.floor(this.x / config.gridSize);
                let gy = Math.floor(this.y / config.gridSize);
                
                if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                    let index = (gy * cols + gx) * 2;
                    // 如果有食物，留下紅色(index+1)，否則留下藍色(index)
                    let pheromoneIndex = this.hasFood ? index + 1 : index;
                    // 費洛蒙累積，設定上限
                    grid[pheromoneIndex] = Math.min(grid[pheromoneIndex] + 0.5, 2.0); 
                }

                // 2. 感測與轉向
                this.senseAndTurn();

                // 3. 移動
                // 加入一點隨機抖動
                this.angle += (Math.random() - 0.5) * 0.1;

                this.x += Math.cos(this.angle) * config.moveSpeed;
                this.y += Math.sin(this.angle) * config.moveSpeed;

                // 4. 邊界處理 (碰到牆壁反彈)
                if (this.x < 0 || this.x > width) {
                    this.angle = Math.PI - this.angle;
                    this.x = Math.max(0, Math.min(width, this.x));
                }
                if (this.y < 0 || this.y > height) {
                    this.angle = -this.angle;
                    this.y = Math.max(0, Math.min(height, this.y));
                }

                // 5. 檢查目標 (家或食物)
                let distToFood = Math.hypot(this.x - food.x, this.y - food.y);
                let distToHome = Math.hypot(this.x - home.x, this.y - home.y);

                if (!this.hasFood && distToFood < food.r + 5) {
                    this.hasFood = true;
                    this.angle += Math.PI; // 轉身
                } else if (this.hasFood && distToHome < home.r + 5) {
                    this.hasFood = false;
                    this.angle += Math.PI; // 轉身
                }
            }

            senseAndTurn() {
                // 有食物時找藍色(0)，沒食物找紅色(1)
                let targetPheromoneOffset = this.hasFood ? 0 : 1;

                // 定義三個感測點：左前、正前、右前
                let sensorLeft = this.getSensorPos(this.angle - config.sensorAngle);
                let sensorFront = this.getSensorPos(this.angle);
                let sensorRight = this.getSensorPos(this.angle + config.sensorAngle);

                let vLeft = this.getPheromoneLevel(sensorLeft.x, sensorLeft.y, targetPheromoneOffset);
                let vFront = this.getPheromoneLevel(sensorFront.x, sensorFront.y, targetPheromoneOffset);
                let vRight = this.getPheromoneLevel(sensorRight.x, sensorRight.y, targetPheromoneOffset);

                // 轉向邏輯
                if (vFront > vLeft && vFront > vRight) {
                    // 繼續直走，微調
                } else if (vFront < vLeft && vFront < vRight) {
                    // 前方最弱，隨機大幅轉向
                    this.angle += (Math.random() - 0.5) * 2 * config.turnSpeed;
                } else if (vLeft > vRight) {
                    this.angle -= config.turnSpeed;
                } else if (vRight > vLeft) {
                    this.angle += config.turnSpeed;
                }
            }

            getSensorPos(angle) {
                return {
                    x: this.x + Math.cos(angle) * config.sensorDist,
                    y: this.y + Math.sin(angle) * config.sensorDist
                };
            }

            getPheromoneLevel(x, y, offset) {
                let gx = Math.floor(x / config.gridSize);
                let gy = Math.floor(y / config.gridSize);
                if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                    return grid[(gy * cols + gx) * 2 + offset];
                }
                return 0;
            }

            draw() {
                ctx.fillStyle = this.hasFood ? '#FFaaaa' : '#ffffff';
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
            }
        }

        // 渲染與主循環
        function loop() {
            // 1. 處理費洛蒙 (揮發與渲染)
            // 為了效能，我們直接操作 ImageData 繪製費洛蒙背景
            // 但簡單起見，這裡用 clearRect 然後畫螞蟻，費洛蒙用像素操作
            
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);

            // 處理費洛蒙網格揮發並繪製
            let imgData = ctx.getImageData(0, 0, width, height);
            let data = imgData.data;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let i = (y * cols + x) * 2;
                    
                    // 揮發
                    grid[i] *= config.evaporationRate;     // Blue (Home scent)
                    grid[i+1] *= config.evaporationRate;   // Red (Food scent)

                    // 閾值過濾 (太小就歸零，節省運算)
                    if (grid[i] < 0.01) grid[i] = 0;
                    if (grid[i+1] < 0.01) grid[i+1] = 0;

                    // 繪製到 Canvas (簡單的放大像素)
                    // 為了效能，我們只畫大格子的左上角像素，或是整塊填色(太慢)
                    // 這裡做一個快速渲染：直接改寫 ImageData
                    // 注意：grid是縮小版的，需要映射到 data (原尺寸)
                    // 為了保持教學代碼簡單且流暢，我們用一個簡化的渲染方式：
                    // 只在費洛蒙夠強時畫點
                    
                    if (grid[i] > 0.05 || grid[i+1] > 0.05) {
                        // 畫一個矩形區域
                        let screenX = x * config.gridSize;
                        let screenY = y * config.gridSize;
                        
                        // 簡單混合顏色
                        let r = Math.min(255, grid[i+1] * 255);
                        let b = Math.min(255, grid[i] * 255);
                        let g = Math.min(255, (grid[i] * 50 + grid[i+1] * 50)); // 稍微加點綠讓重疊處變亮

                        // 填滿格子
                        for(let dy=0; dy<config.gridSize; dy++) {
                            for(let dx=0; dx<config.gridSize; dx++) {
                                let py = screenY + dy;
                                let px = screenX + dx;
                                if (px < width && py < height) {
                                    let pIndex = (py * width + px) * 4;
                                    data[pIndex] = r;     // R
                                    data[pIndex+1] = g;   // G
                                    data[pIndex+2] = b;   // B
                                    data[pIndex+3] = 255; // Alpha
                                }
                            }
                        }
                    }
                }
            }
            ctx.putImageData(imgData, 0, 0);

            // 2. 更新與繪製螞蟻
            for (let ant of ants) {
                ant.update();
                ant.draw();
            }

            // 3. 繪製家和食物
            ctx.beginPath();
            ctx.arc(home.x, home.y, home.r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(76, 175, 80, 0.8)';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.fillText("家", home.x - 5, home.y + 4);

            ctx.beginPath();
            ctx.arc(food.x, food.y, food.r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(244, 67, 54, 0.8)';
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.fillText("食物", food.x - 10, food.y + 4);

            requestAnimationFrame(loop);
        }

        // UI 事件綁定
        document.getElementById('antCount').addEventListener('input', (e) => {
            config.antCount = parseInt(e.target.value);
            document.getElementById('antCountVal').textContent = config.antCount;
            // 如果數量增加，補新的螞蟻；減少則截斷
            if (ants.length < config.antCount) {
                for(let i = ants.length; i < config.antCount; i++) ants.push(new Ant());
            } else {
                ants.length = config.antCount;
            }
        });

        document.getElementById('evaporation').addEventListener('input', (e) => {
            config.evaporationRate = parseFloat(e.target.value);
            document.getElementById('evapVal').textContent = config.evaporationRate;
        });
        
        document.getElementById('sensorDist').addEventListener('input', (e) => {
            config.sensorDist = parseInt(e.target.value);
            document.getElementById('sensorVal').textContent = config.sensorDist;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetGrid();
            for(let ant of ants) ant.reset();
        });

        // 滑鼠互動 (拖曳)
        let activeObject = null;

        canvas.addEventListener('mousedown', (e) => {
            let rect = canvas.getBoundingClientRect();
            let mx = e.clientX - rect.left;
            let my = e.clientY - rect.top;

            if (Math.hypot(mx - home.x, my - home.y) < home.r + 10) {
                activeObject = home;
            } else if (Math.hypot(mx - food.x, my - food.y) < food.r + 10) {
                activeObject = food;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (activeObject) {
                let rect = canvas.getBoundingClientRect();
                activeObject.x = e.clientX - rect.left;
                activeObject.y = e.clientY - rect.top;
                
                // 如果移動的是家，重置所有螞蟻位置到家裡看起來比較自然
                // 但這裡我們不重置螞蟻，讓它們自己找新路
            }
        });

        canvas.addEventListener('mouseup', () => {
            activeObject = null;
        });

        window.addEventListener('resize', () => {
            // 簡單處理：重新整理頁面或重新計算畫布
            resize();
        });

        // 啟動
        init();

    </script>
</body>
</html>